#!/usr/bin/env node

import 'babel-polyfill';

import commander from 'commander';
import glob from 'glob';
import path from 'path';

import jScrambler from '../lib';
import {mergeAndParseParams} from '../lib/cli';

commander
  .version(require('../../package.json').version)
  .usage('[source files] [options]')
  .option('-c, --config [config]', 'JScrambler configuration options')
  .option('-o, --output [output]', 'Output directory. If not specified the output is printed.')
  .option('-a, --access-key <accessKey>', 'Access key')
  .option('-s, --secret-key <secretKey>', 'Secret key')
  .option('-h, --host [host]', 'Hostname')
  .option('-p, --port [port]', 'Port')
  .option('-i, --applicationId [applicationId]', 'Application ID')
  .parse(process.argv);

var globSrc, config;

// If -c, --config file was provided
if (commander.config) {
  // We're using `commander` (CLI) as the source of all truths, falling back to
  // the `config` provided by the file passed as argument
  config = require(path.resolve(commander.config, '.'));
  commander.output = commander.output || config.filesDest;
  // No need to validate if `keys` are set, later `client` will do so, but first
  // will try to load to the configuration through an `rc` file
  if (config.keys) {
    commander.accessKey = commander.accessKey || config.keys.accessKey;
    commander.secretKey = commander.secretKey || config.keys.secretKey;
  }
  commander.host = commander.host || config.host;
  commander.port = commander.port || config.port;
  commander.applicationId = commander.applicationId || config.applicationId;
  globSrc = config.filesSrc;
}

// If src paths have been provided
if (commander.args.length > 0) {
  globSrc = commander.args;
}

if (globSrc && globSrc.length) {
  var filesSrc = [];
  // Iterate `globSrc` to build a list of source files into `filesSrc`
  for (let i = 0, l = globSrc.length; i < l; ++i) {
    // Calling sync `glob` because async is pointless for the CLI use case
    // (as of now at least)
    filesSrc = filesSrc.concat(glob.sync(globSrc[i], {
      dot: true
    }));
  }
}
// If there's no output directory and we're handling more than one file we can't
// output to CLI so it's pointless to execute the command.
if (!commander.output && (!filesSrc || filesSrc.length > 1)) {
  console.error('Destination must be specified unless only one file is used as input');
  process.exit(1);
}


if (!commander.applicationId) {
  console.error('Application ID is required but was not provided');
  process.exit(1);
}

const {
  applicationId,
  output: filesDest,
  accessKey,
  secretKey,
  host,
  port
} = commander;

const params = mergeAndParseParams(commander, config && config.params);

// Go, go, go
(async () => {
  try {
    await jScrambler
      .protectAndDownload({
        keys: {
          accessKey,
          secretKey
        },
        host,
        port,
        applicationId,
        filesSrc,
        filesDest,
        params
      });
  } catch (error) {
    console.error(error);
    process.exit(1);
  }
})();
